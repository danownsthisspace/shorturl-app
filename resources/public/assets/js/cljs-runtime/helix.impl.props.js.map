{"version":3,"sources":["helix/impl/props.cljc"],"mappings":"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","names":["helix.impl.props/aria-data-css-custom-prop-special-case-re","helix.impl.props/camel-regexp","js/RegExp","helix.impl.props/camel-case","s","cljs.core/Keyword","cljs.core/Symbol","name-str","cljs.core/name","cljs.core._EQ_","p1__31347#","p2__31346#","helix.impl.props/kw->str","kw","kw-ns","cljs.core/namespace","kw-name","helix.impl.props/set-obj","o","k","v","G__31349","helix.impl.props.goog$module$goog$object.set","helix.impl.props/->js","x","cljs.core.clj__GT_js","cljs.core.comp","var_args","G__31351","helix.impl.props/primitive-obj","js/Error","m","helix.impl.props.primitive_obj","cljs.core/seq","cljs.core/rest","entry","cljs.core/first","cljs.core/key","cljs.core/val","helix.impl.props/into-js-array","aseq","cljs.core.into_array","helix.impl.props/merge-obj","o1","o2","G__31353","helix.impl.props.goog$module$goog$object.extend","helix.impl.props/seq-to-class","class","cljs.core.remove","cljs.core/nil?","cljs.core.map","cljs.core/str","clojure.string.join","helix.impl.props/normalize-class","cljs.core/sequential?","helix.impl.props/or-undefined","js/undefined","helix.impl.props/dom-style","style","cljs.core/map?","cljs.core/vector?","p1__31354#","G__31358","helix.impl.props/-dom-props","helix.impl.props._dom_props","G__31359","G__31362","helix.impl.props/-props","helix.impl.props._props"],"sourcesContent":["(ns helix.impl.props\n  (:require [clojure.string :as string]\n            #?@(:cljs [[cljs-bean.core :as b]\n                       [goog.object :as gobj]]))\n  #?(:cljs (:require-macros [helix.impl.props])))\n\n(def aria-data-css-custom-prop-special-case-re #\"^(aria-|data-|--).*\")\n\n#?(:cljs (def camel-regexp (js/RegExp \"-(\\\\w)\", \"g\")))\n\n(defn camel-case\n  \"Returns camel case version of the string, e.g. \\\"http-equiv\\\" becomes \\\"httpEquiv\\\".\"\n  [s]\n  (if (or (keyword? s)\n          (string? s)\n          (symbol? s))\n    (let [name-str (name s)]\n      ; this is hot path so we want to use low-level interop\n      #?(:clj  (cond\n                 (some? (re-matches aria-data-css-custom-prop-special-case-re name-str)) name-str\n                 (= (subs name-str 0 1) \"'\") (subs name-str 1)\n                 :else (string/replace name-str #\"-(\\w)\" #(string/upper-case (second %))))\n         :cljs (cond\n                 (some? (.match name-str aria-data-css-custom-prop-special-case-re)) name-str\n                 (= (.substring name-str 0 1) \"'\") (.substring name-str 1)\n                 :else (.replace name-str camel-regexp #(.toUpperCase %2)))))\n      s))\n\n(comment\n  (camel-case \"get-asdf-aw9e8f\"))\n\n(defn kw->str [kw]\n  (let [kw-ns (namespace kw)\n        kw-name (name kw)]\n    (if (nil? kw-ns)\n      kw-name\n      (str kw-ns \"/\" kw-name))))\n\n\n(defn set-obj [o k v]\n  #?(:clj (conj o k v)\n     :cljs (doto o (gobj/set k v))))\n\n#?(:cljs (defn ->js [x]\n           (clj->js x :keyword-fn (comp camel-case name))))\n\n(defn primitive-obj\n  ([] #?(:clj '[cljs.core/js-obj]\n         :cljs #js {}))\n  ([m]\n   #?(:clj (if (map? m)\n             (primitive-obj m (primitive-obj))\n             ;; fall back to runtime\n             `(primitive-obj ~m))\n      :cljs (primitive-obj m (primitive-obj))))\n  ([m o]\n   (if (seq m)\n     (recur (rest m)\n            (let [entry (first m)]\n              (set-obj o\n                       (camel-case (kw->str (key entry)))\n                       #?(:clj `(->js ~(val entry))\n                          :cljs (->js (val entry))))))\n     #?(:clj (list* o)\n        :cljs o))))\n\n(defn into-js-array [aseq]\n  #?(:clj (list* (into '[cljs.core/array] aseq))\n     :cljs (into-array aseq)))\n\n#?(:cljs\n   (defn merge-obj [o1 o2]\n     (if (nil? o2)\n       o1\n       (doto o1\n         (gobj/extend o2)))))\n\n(defn seq-to-class [class]\n  (->> class\n       (remove nil?)\n       (map str)\n       (string/join \" \")))\n\n#?(:clj\n   (defn unquote-class\n     \"Handle the case of (quote '[foo bar])\"\n     [class]\n     (if (sequential? class)\n       (seq-to-class class)\n       (str class))))\n\n#?(:clj\n   (defn normalize-class [class]\n     (cond\n       (string? class)\n       class\n\n       (and (list? class)\n            (= (first class) 'quote))\n       (unquote-class (second class))\n\n       :default\n       `(normalize-class ~class))))\n\n#?(:cljs\n   (defn normalize-class [class]\n     (cond\n       ;; quick path\n       (string? class) class\n\n       (sequential? class) (seq-to-class class)\n\n       ;; not a string or sequential, stringify it\n       true (str class))))\n\n\n#?(:cljs\n   (defn or-undefined\n     [v]\n     (if (nil? v)\n       js/undefined\n       v)))\n\n\n(defn dom-style\n  [style]\n  (cond\n    ;; when map, convert to an object w/ camel casing\n    (map? style) (primitive-obj style)\n    ;; React Native allows arrays of styles\n    (vector? style) (into-js-array (map #(if (map? %) (primitive-obj %) %) style))\n    ;; if anything else, at compile time fall back to runtime\n    ;; at runtime just pass it through and assume it's a JS style obj!\n    true #?(:clj `(dom-style ~style)\n            :cljs style)))\n\n\n(defn -dom-props\n  ([m] #?(:clj (if-let [spread-sym (cond\n                                     (contains? m '&) '&\n                                     (contains? m :&) :&)]\n                 `(merge-obj ~(-dom-props (dissoc m spread-sym) (primitive-obj))\n                             (-dom-props ~(get m spread-sym)))\n                 (-dom-props m (primitive-obj)))\n          :cljs (if (map? m)\n                  (-dom-props m (primitive-obj))\n                  ;; assume JS obj\n                  m)))\n  ([m o]\n   (if (seq m)\n     (recur (rest m)\n            (let [entry (first m)\n                  k (key entry)\n                  v (val entry)]\n              (case k\n                :class (set-obj o \"className\" (normalize-class v))\n                :for (set-obj o \"htmlFor\" v)\n                :style (set-obj o \"style\" (dom-style v))\n                :value (set-obj o \"value\" #?(:clj `(or-undefined ~v)\n                                             :cljs (or-undefined v)))\n                (set-obj o (camel-case (kw->str k)) v))))\n     #?(:clj (list* o)\n        :cljs o))))\n\n\n(comment\n  (-dom-props {:asdf \"jkl\" :style 'foo})\n\n  (-dom-props {:style [\"fs1\"]})\n  )\n\n(defmacro dom-props [m]\n  (-dom-props m))\n\n\n(defn -props\n  ([m] #?(:clj (if-let [spread-sym (cond\n                                     (contains? m '&) '&\n                                     (contains? m :&) :&)]\n                 `(merge-obj ~(-props (dissoc m spread-sym) (primitive-obj))\n                             (-props ~(get m spread-sym)))\n                 (-props m (primitive-obj)))\n          :cljs (if (map? m)\n                  (-props m (primitive-obj))\n                  m)))\n  ([m o]\n   (if (seq m)\n     (recur (rest m)\n            (let [entry (first m)]\n              (set-obj o (kw->str (key entry)) (val entry))))\n     #?(:clj (list* o)\n        :cljs o))))\n\n(comment\n  (-props {:foo-bar \"baz\"})\n  )\n\n(defmacro props [m]\n  (-props m))\n"]}