{"version":3,"sources":["promesa/core.cljc"],"mappings":";AA2CA;;;wBAAA,xBAAMA,wDAEHC;AAFH,AAGE,OAACC,sBAAcD;;AAEjB;;;wBAAA,xBAAME,wDAEHF;AAFH,AAGE,OAACG,sBAAcH;;AAEjB;;;wBAAA,xBAAMI;AAAN,AAGE,OAACC;;AAEH,AAAA;;;;;;;uBAAA,+BAAAC,tDAAME;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,mDAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,mDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,qDAAA,rDAAMD,gEAMFR;AANJ,AAOG,OAACU,2BAAYV;;;AAPhB,CAAA,qDAAA,rDAAMQ,gEAQFR,EAAEW;AARN,AASG,OAACC,uBAAQ,AAACF,2BAAYV,GAAGa,mBAASF;;;AATrC,CAAA,+CAAA,/CAAMH;;AAAN,AAWA;;;;oBAAA,pBAAMM,gDAGHd;AAHH,AAIE,OAACU,2BAAYV;;AAEf,AAAA;;;;;;sBAAA,8BAAAM,pDAAMU;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,kDAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,kDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAP,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,oDAAA,pDAAMO,+DAKFC;AALJ,AAMG,IAAQC,IAAE,AAACb;AAAX,AACE,IAAA,AACE,IAAAe,iBAAA,WAAAC;AAAA,AAAI,0CAAAA,nCAACG,iCAAaN;;IAAlBI,iBAAA,WAAAC;AAAA,AACI,yCAAAA,lCAACE,gCAAYP;;AADjB,AAAA,mEAAAE,eAAAE,8BAAAF,eAAAE,9HAACL,kCAAAA,iEAAAA;gBADH,cAAAE,VAG2CO;AAH3C,AAII,AAACD,gCAAYP,EAAEQ;;AACnBR;;;AAZL,CAAA,oDAAA,pDAAMF,+DAaFC,EAAEN;AAbN,AAcG,IAAQO,IAAE,AAACb;AAAX,AACE,AAACsB,qDAAUhB,SAAS;AAAA,AACE,IAAA,AACE,IAAAkB,WAAA,WAAAC;AAAA,AAAI,0CAAAA,nCAACN,iCAAaN;;IAAlBa,WAAA,WAAAC;AAAA,AACI,yCAAAA,lCAACP,gCAAYP;;AADjB,AAAA,0EAAAW,SAAAE,wBAAAF,SAAAE,5GAACd,kCAAAA,qDAAAA;gBADH,QAAAW,JAG2CF;AAH3C,AAII,OAACD,gCAAYP,EAAEQ;;;AACzCR;;;AArBL,CAAA,8CAAA,9CAAMF;;AAAN,AAuBA;;;8BAAA,9BAAMiB,oEAEHjC;AAFH,AAGE,GAAA,GAAA,MAAA,LAAwBA;AAAxB,GAAA,EAAA,WAAA,CAAAkC,gCAAA,AAAwBlC;AAAxB;;AAAA,GAAA,EAAA,AAAwBA;AAAxB,OAAAmC,kCAAYC,2BAAYpC;;AAAxB;;;;AAAA,OAAAmC,kCAAYC,2BAAYpC;;;AAK1B;;;+BAAA,/BAAMqC,sEAEHrC;AAFH,AAIW,qBAAWsC,bAAuBtC;;AAG1C;;;+BAAA,/BAAMuC,sEAEHvC;AAFH,AAGE,SAAK,AAACwC,wBAAQxC,QAAG,AAACyC,oBAAI,GAAA,FAAezC;;AAI1C;;;+BAAA,/BAAM0C,sEAEHC;AAFH,AAGE,OAACC,mCAAcD;;AAEjB;;;+BAAA,/BAAME,sEAEHF;AAFH,AAGE,OAACG,mCAAcH;;AAEjB;;;8BAAA,9BAAMI,oEAEHJ;AAFH,AAGE,OAACK,kCAAaL;;AAEhB;;;uBAAA,vBAAMM,sDAEHN;AAFH,AAGE,OAACO,2BAAYP;;AAEf;;;AAAKQ,2BAEH,AAACC,qBAAWL;AAId,AAAA;;;;;;;;;;oBAAA,4BAAAzC,hDAAMgD;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,gDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,gDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA7C,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,kDAAA,lDAAM6C,6DASFX,EAAE1B;AATN,AAUG,OAACsC,wBAAS,AAAC7C,2BAAYiC,GAAG1B;;;AAV7B,CAAA,kDAAA,lDAAMqC,6DAWFX,EAAE1B,EAAEN;AAXR,AAYG,OAAC4C,wBAAS,AAAC7C,2BAAYiC,GAAG1B,EAAEN;;;AAZ/B,CAAA,4CAAA,5CAAM2C;;AAAN,AAcA,AAAA,oBAAA,4BAAAhD,hDAAMmD;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,gDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,gDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAhD,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,kDAAA,lDAAMgD,6DACFd,EAAE1B;AADN,AAEG,OAACyC,wBAAS,AAAChD,2BAAYiC,GAAG1B;;;AAF7B,CAAA,kDAAA,lDAAMwC,6DAGFd,EAAE1B,EAAEN;AAHR,AAIG,OAAC+C,wBAAS,AAAChD,2BAAYiC,GAAG1B,EAAEN;;;AAJ/B,CAAA,4CAAA,5CAAM8C;;AAAN,AAMA,AAAA;;;;;;;;;iCAAA,yCAAAnD,1EAAMsD;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,6DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,6DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAnD,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,+DAAA,/DAAMmD,0EAQFjB,EAAE1B;AARN,AASG,OAACL,uBAAQ,AAACF,2BAAYiC,GAAG1B;;;AAT5B,CAAA,+DAAA,/DAAM2C,0EAUFjB,EAAE1B,EAAEN;AAVR,AAWG,OAACC,uBAAQ,AAACF,2BAAYiC,GAAG1B,EAAEN;;;AAX9B,CAAA,yDAAA,zDAAMiD;;AAAN,AAaA,AAAA;;;;;;;mBAAA,2BAAAtD,9CAAMwD;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,+CAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,+CAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAArD,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,iDAAA,jDAAMqD,4DAMF7C,EAAE0B;AANN,AAOG,OAAC/B,uBAAQ,AAACF,2BAAYiC,GAAG1B;;;AAP5B,CAAA,iDAAA,jDAAM6C,4DAQFnD,SAASM,EAAE0B;AARf,AASG,OAAC/B,uBAAQ,AAACF,2BAAYiC,GAAG1B,EAAEN;;;AAT9B,CAAA,2CAAA,3CAAMmD;;AAAN,AAWA,AAAA;;;;;;;;;;sBAAA,8BAAAxD,pDAAM0D;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,kDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,kDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAvD,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,oDAAA,pDAAMuD,+DASF/C,EAAE0B;AATN,AAUG,OAACe,wBAAS,AAAChD,2BAAYiC,GAAG1B;;;AAV7B,CAAA,oDAAA,pDAAM+C,+DAWFrD,SAASM,EAAE0B;AAXf,AAYG,OAACe,wBAAS,AAAChD,2BAAYiC,GAAG1B,EAAEN;;;AAZ/B,CAAA,8CAAA,9CAAMqD;;AAAN,AAcA,AAAA;;;;;qBAAA,6BAAA1D,lDAAM4D;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,iDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,IAAAC,yBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,4BAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,KAAAC,qBAAA,AAAAJ,6BAAA,KAAA,IAAA;AAAA,AAAA,OAAAD,wDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAAI;;;;;AAAA,CAAA,mDAAA,nDAAMJ,8DAIFvB,EAAE1B;AAJN,AAIS,OAAC6D,gDAAKnC,EAAE1B;;;AAJjB,AAAA,CAAA,0DAAA,1DAAMiD,qEAKFvB,EAAE1B,EAAI8D;AALV,AAKc,sDAAA,WAAAC,iBAAAC,3EAACC;AAAD,AAAS,uDAAAF,iBAAAC,jEAACH;GAAYnC,EAAE,AAACwC,eAAKlE,EAAE8D;;;AAL9C;AAAA,CAAA,uCAAA,WAAAP,lDAAMN;AAAN,AAAA,IAAAO,WAAA,AAAAC,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;IAAAI,WAAA,AAAAF,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;AAAA,AAAA,IAAAK,qBAAA;AAAA,AAAA,OAAAA,wDAAAJ,SAAAG,SAAAJ;;;AAAA,CAAA,6CAAA,7CAAMN;;AAAN,AAOA,AAAA;;;;;kCAAA,0CAAA5D,5EAAM+E;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,8DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,IAAAlB,yBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,4BAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,KAAAC,qBAAA,AAAAJ,6BAAA,KAAA,IAAA;AAAA,AAAA,OAAAkB,qEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAAf;;;;;AAAA,CAAA,gEAAA,hEAAMe,2EAIF1C,EAAE1B;AAJN,AAIS,OAACwE,6DAAM9C,EAAE1B;;;AAJlB,AAAA,CAAA,uEAAA,vEAAMoE,kFAKF1C,EAAE1B,EAAI8D;AALV,AAKc,OAACG,+CAAOtE,uBAAQ,AAACF,2BAAYiC,GAAG,AAACwC,eAAKlE,EAAE8D;;;AALtD;AAAA,CAAA,oDAAA,WAAAO,/DAAMD;AAAN,AAAA,IAAAE,WAAA,AAAAb,gBAAAY;IAAAA,eAAA,AAAAX,eAAAW;IAAAE,WAAA,AAAAd,gBAAAY;IAAAA,eAAA,AAAAX,eAAAW;AAAA,AAAA,IAAAT,qBAAA;AAAA,AAAA,OAAAA,wDAAAU,SAAAC,SAAAF;;;AAAA,CAAA,0DAAA,1DAAMD;;AAAN,AAOA,AAAA;;;;sBAAA,8BAAA/E,pDAAMqF;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,kDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,kDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAlF,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,oDAAA,pDAAMkF,+DAGFhD,EAAE1B;AAHN,AAIG,OAAC2E,0BAAW,AAAClF,2BAAYiC,GAAG1B;;;AAJ/B,CAAA,oDAAA,pDAAM0E,+DAKFhD,EAAE1B,EAAEN;AALR,AAMG,OAACiF,0BAAW,AAAClF,2BAAYiC,GAAG1B,EAAEN;;;AANjC,CAAA,8CAAA,9CAAMgF;;AAAN,AAQA,AAAA;;;;;;;wBAAA,+BAAArF,vDAAMwF;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,oDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,oDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAArF,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,sDAAA,tDAAMqF,iEAMFnD,EAAE1B;AANN,AAOG,OAAC8E,2BAAY,AAACrF,2BAAYiC,GAAG1B;;;AAPhC,CAAA,sDAAA,tDAAM6E,iEAQFnD,EAAE1B,EAAEN;AARR,AASG,OAACoF,2BAAY,AAACrF,2BAAYiC,GAAG1B,EAAEN;;;AATlC,CAAA,gDAAA,hDAAMmF;;AAAN,AAWA,AAAA;;;;sBAAA,6BAAAxF,nDAAM2F;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,kDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,kDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAxF,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,oDAAA,pDAAMwF,+DAGFtD,EAAE1B;AAHN,AAIG,OAACiF,2BAAY,AAACxF,2BAAYiC,GAAG1B;;;AAJhC,CAAA,oDAAA,pDAAMgF,+DAKFtD,EAAEwD,aAAalF;AALnB,AAMG,IAAQmF,gBAAQ,mDAAA,WAAAC,5DAAI,AAACC,qBAAKH,eACRA;AADF,AAEG,QAAAE,4BAAWF;;AAF9B,AAGE,OAACD,2BACA,AAACxF,2BAAYiC,GACb,WAAKjB;AAAL,AACE,oBAAI,CAAC0E,8CAAAA,iDAAAA,LAAQ1E,6BAAAA;AACX,QAACT,kCAAAA,qCAAAA,LAAES,iBAAAA;;AACH,OAACvB,sBAAcuB;;;;;AAdzB,CAAA,8CAAA,9CAAMuE;;AAAN,AAgBA,AAAA;;;;kCAAA,0CAAA3F,5EAAMkG;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,8DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,8DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA/F,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,gEAAA,hEAAM+F,2EAGF7D,EAAE1B;AAHN,AAIG,OAACwF,0BAAW,AAAC/F,2BAAYiC,GAAG1B;;;AAJ/B,CAAA,gEAAA,hEAAMuF,2EAKF7D,EAAEwD,aAAalF;AALnB,AAMG,IAAQmF,gBAAQ,mDAAA,WAAAM,5DAAI,AAACJ,qBAAKH,eACRA;AADF,AAEG,QAAAO,4BAAWP;;AAF9B,AAGE,OAACM,0BACA,AAAC/F,2BAAYiC,GACb,WAAKjB;AAAL,AACE,oBAAI,CAAC0E,8CAAAA,iDAAAA,LAAQ1E,6BAAAA;AACX,QAACT,kCAAAA,qCAAAA,LAAES,iBAAAA;;AACH,OAACvB,sBAAcuB;;;;;AAdzB,CAAA,0DAAA,1DAAM8E;;AAAN,AAgBA,AAAA;;;qBAAA,6BAAAlG,lDAAMsG;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,iDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,iDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAnG,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,mDAAA,nDAAMmG,8DAEF3F,EAAE0B;AAFN,AAES,OAACkE,kDAAMlE,EAAE1B;;;AAFlB,CAAA,mDAAA,nDAAM2F,8DAGF3F,EAAE6F,KAAKnE;AAHX,AAGc,OAACkE,kDAAMlE,EAAEmE,KAAK7F;;;AAH5B,CAAA,6CAAA,7CAAM2F;;AAAN,AAKA;;;AAAKG,mBAEHH;AAEF;;;;;;;;;;;;;;;;;;mBAAA,nBAAMI,8CAiBHC;AAjBH,oEAkBiB,AAAM3E,6CAAuB,AAAC4E,mDAAWD,pKACzC,OAACxB,wKAAM0B;;AAOxB,oBAAA,pBAAMC,gDACHH;AADH,AAEW,OAAO3E,8CAAuB,AAAC4E,mDAAW,AAACG,4CAAc3G,2BAAYuG;;AAIhF,AAAA;;;;mBAAA,2BAAA3G,9CAAMiH;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,+CAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,+CAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA9G,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,iDAAA,jDAAM8G,4DAGFN;AAHJ,AAIG,+DAAA,xDAACO,+CAAIP;;;AAJR,CAAA,iDAAA,jDAAMM,4DAKFN,SAASQ;AALb,AAMG,IAAQC,QAAM,6CAAA,2CAAA,4DAAA,MAAA,oFAAA,kEAAA,hTAACC,oNACe,AAACC,gBAAMX;AADrC,AAGE,OAACY,kDACA,WAAKC,QAAQC;AAAb,AACE,IAAAC,aAAA,AAAAC,cAAUhB;IAAViB,eAAA;IAAAC,eAAA;IAAAC,WAAA;;AAAA,AAAA,GAAA,AAAA,CAAAA,WAAAD;AAAA,QAAA,AAAAD,kDAAAE,tDAAQzF;AAAR,AAAA,kGACQ,AAACjC,2BAAYiC,3EACb,AAACmC,8EAAK,hIAON,AAAC+B;kBAPU7G;AAAL,AACE,oBAAU,AAAA,0FAAA,AAAA0I,gBAAYhB;AAAtB;;AAAA,AACE,AAACiB,mDAAMjB,MAAM;kBAAKA;AAAL,oGACQA,9CACA,wDAAA,4DAAA,pHAACkB,tDACD,gLAAA,zKAACC,mOAAgBC;;;;AACtC,QAAChB,wCAAAA,2CAAAA,LAAQ9H,uBAAAA;;;EACZ;kBAAK0B;AAAL,AACE,AAACiH,mDAAMjB,MAAM;kBAAKA;AAAL,qGACQA,/CACA,yDAAA,zDAACmB,mHAAiBC,zKAClB,wLAAA,jLAACD,mPAAmBE,eAAKrH;;;;AAC9C,IAAAsH,aAAA,AAAAN,gBAA+ChB;IAA/CsB,iBAAA,AAAAC,4BAAAD;eAAA,AAAAE,4CAAAF,eAAA,tEAAgBI;cAAhB,AAAAF,4CAAAF,eAAA,rEAAyBK;iBAAzB,AAAAH,4CAAAF,eAAA,xEAAiCM;AAAjC,AACE,GAAM,EAAK,AAACC,cAAIH,eAAU,qDAAA,rDAACI,6CAAEH;AAA7B,AACE,GAAI,sDAAA,tDAACG,6CAAE/B;AACL,IAAAgC,WAAQ,gDAAA,uBAAA,2CAAA,lHAACE,oLACqBL;AAD9B,AAAA,oFAAAG,6BAAAA,zGAAC1B,uCAAAA,iDAAAA;;AAED,QAACD,wCAAAA,kDAAAA,ZAAQL,8BAAAA;;;AAJb;;;;;AAfnB;AAAA,eAAAO;eAAAE;eAAAC;eAAA,CAAAC,WAAA;;;;;;;AAAA,IAAAC,qBAAA,AAAAJ,cAAAD;AAAA,AAAA,GAAAK;AAAA,AAAA,IAAAL,iBAAAK;AAAA,AAAA,GAAA,AAAAC,6BAAAN;AAAA,IAAAO,kBAAA,AAAAC,sBAAAR;AAAA,AAAA,eAAA,AAAAS,qBAAAT;eAAAO;eAAA,AAAAX,gBAAAW;eAAA;;;;;;;AAAA,QAAA,AAAA7D,gBAAAsD,pBAAQrF;AAAR,AAAA,kGACQ,AAACjC,2BAAYiC,3EACb,AAACmC,8EAAK,hIAON,AAAC+B;kBAPU7G;AAAL,AACE,oBAAU,AAAA,0FAAA,AAAA0I,gBAAYhB;AAAtB;;AAAA,AACE,AAACiB,mDAAMjB,MAAM;kBAAKA;AAAL,oGACQA,9CACA,wDAAA,4DAAA,pHAACkB,tDACD,gLAAA,zKAACC,mOAAgBC;;;;AACtC,QAAChB,wCAAAA,2CAAAA,LAAQ9H,uBAAAA;;;EACZ;kBAAK0B;AAAL,AACE,AAACiH,mDAAMjB,MAAM;kBAAKA;AAAL,qGACQA,/CACA,yDAAA,zDAACmB,mHAAiBC,zKAClB,wLAAA,jLAACD,mPAAmBE,eAAKrH;;;;AAC9C,IAAAyH,aAAA,AAAAT,gBAA+ChB;IAA/CyB,iBAAA,AAAAF,4BAAAE;eAAA,AAAAD,4CAAAC,eAAA,tEAAgBC;cAAhB,AAAAF,4CAAAC,eAAA,rEAAyBE;iBAAzB,AAAAH,4CAAAC,eAAA,xEAAiCG;AAAjC,AACE,GAAM,EAAK,AAACC,cAAIH,eAAU,qDAAA,rDAACI,6CAAEH;AAA7B,AACE,GAAI,sDAAA,tDAACG,6CAAE/B;AACL,IAAAiC,WAAQ,gDAAA,uBAAA,2CAAA,lHAACC,oLACqBL;AAD9B,AAAA,oFAAAI,6BAAAA,zGAAC3B,uCAAAA,iDAAAA;;AAED,QAACD,wCAAAA,kDAAAA,ZAAQL,8BAAAA;;;AAJb;;;;;AAfnB;AAAA,eAAA,AAAA9C,eAAAqD;eAAA;eAAA;eAAA;;;;;;;;AAAA;;;;;;;;AAXR,CAAA,2CAAA,3CAAMT;;AAAN,AAgCA,AAAA;;;yBAAA,iCAAAjH,1DAAMuJ;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,qDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,qDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAApJ,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,uDAAA,vDAAMoJ,kEAEF5I,EAAE6I;AAFN,AAEY,OAACC,qDAAK9I,EAAE6I,KAAKE;;;AAFzB,CAAA,uDAAA,vDAAMH,kEAGF5I,EAAE6I,KAAKnJ;AAHX,AAGqB,sDAAA,WAAAsJ,iBAAAC,3EAAChF;AAAD,AAAS,uDAAA+E,hDAACnF,iEAAQ,WAAKqF;AAAL,AAAQ,0EAAAD,gCAAAA,lGAACjJ,kCAAAA,oDAAAA;;GAAQ,mDAAA,nDAACmJ,wDAAYzJ,UAAUmJ;;;AAH/E,CAAA,iDAAA,jDAAMD;;AAAN,AAOA;;;4BAAA,5BAAMQ,gEAEH1H;AAFH,AAGE,AAAC2H,gCAAY3H;;AACbA;;AAEF;;;gCAAA,hCAAM4H,wEAEHvK;AAFH,AAGE,OAACwK,oCAAexK;;AAIlB,AAAA;;;6BAAA,qCAAAM,lEAAMoK;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,yDAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,yDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAjK,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,2DAAA,3DAAMiK,sEAEFC;AAFJ,AAEO,0CAAA,nCAACnJ,iCAAamJ;;;AAFrB,CAAA,2DAAA,3DAAMD,sEAGFC,EAAE3K;AAHN,AAGS,OAACwB,iCAAamJ,EAAE3K;;;AAHzB,CAAA,qDAAA,rDAAM0K;;AAAN,AAKA;;;4BAAA,5BAAME,gEAEHjI,EAAEjB;AAFL,AAGE,OAACD,gCAAYkB,EAAEjB;;AAIjB;;;;;yBAAA,zBAAMmJ,0DAIHC;AAJH,AAKE;mCAAOC;AAAP,AACE,OAAClD,kDAAO,WAAKC,QAAQC;AAAb,AACG,IAAQgD,wDAAW,AAAC5D,cAAI4D,3DAAM,AAACC,iEAAKlD;AAApC,AACE,IAAA,AACE,OAACoD,8CAAMJ,SAASC;gBADlB,GAAA,CAAAE,kBAEiCxK;AAFjC,QAAAwK,JAE2CvJ;AAF3C,AAGI,QAACqG,uCAAAA,0CAAAA,LAAOrG,sBAAAA;;AAHZ,AAAA,MAAAuJ;;;;;;IAHRF;;;;EAAAA;;oCAAAA;;;IAAAA;0BAAAA;;;;;;;AASN;;;gCAAA,hCACEI,wEAAkBC;AADpB,AAEE,SAAA,LAASC;AAAT,AACE,sBAAA,mCAAA,zDAAO5K,WAAS4K,GAAGD;;AACnBC;;AAEE,AAACC,cAAcH,8BAAiB1K;AAEzC,AAAA;;;;;;uBAAA,+BAAAH,tDAAMkL;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,mDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,mDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,mDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA/K,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,qDAAA,rDAAM+K,gEAKF7I,EAAE8I;AALN,AAKS,8DAAA,vDAACC,mDAAQ/I,EAAE8I,oFAAYE;;;AALhC,CAAA,qDAAA,rDAAMH,gEAMF7I,EAAE8I,EAAEzL;AANR,AAMW,OAAC0L,mDAAQ/I,EAAE8I,EAAEzL,EAAE2L;;;AAN1B,CAAA,qDAAA,rDAAMH,gEAOF7I,EAAE8I,EAAEzL,EAAE4L;AAPV,AAQG,IAAQC,UAAQ,AAACzL;IACT0L,MAAQ,sEAAA,tEAACC,0DAAeH,UAAUH;AAA1B,AAA6B,GAAI,+CAAA,/CAACjC,6CAAExJ;AACL,OAAC4K,0BAAQiB,QAAQ,KAAAV,8BAAA;;AACjB,OAACa,yDAASH,QAAQ7L;;;AAHjE,AAIE,yBAAA,lBAACoH,qGAAM,AAAC6E,oDAAQtJ,EAAE,WAAKwH,EAAEA;AAAP,AAAU,OAACG,gCAAYwB;IAAOD;;;AAZrD,CAAA,+CAAA,/CAAML;;AAAN,AAcA,AAAA;;;;;qBAAA,6BAAAlL,lDAAM6L;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,iDAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,iDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,iDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA1L,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,mDAAA,nDAAM0L,8DAIFV;AAJJ,AAIO,0DAAA,nDAACW,iDAAMX,OAAME;;;AAJpB,CAAA,mDAAA,nDAAMQ,8DAKFV,EAAEzL;AALN,AAKS,OAACoM,iDAAMX,EAAEzL,EAAE2L;;;AALpB,CAAA,mDAAA,nDAAMQ,8DAMFV,EAAEzL,EAAE4L;AANR,AAOG,IAAQ1K,IAAE,AAACd;AAAX,AACE,sEAAA,tEAAC2L,0DAAeH,UAAUH;AAA1B,AAA6B,OAACO,yDAAS9K,EAAElB;;;AACzCkB;;;AATL,CAAA,6CAAA,7CAAMiL;;AAAN,AAmEA,AAAeE,uCAAcC","names":["promesa.core/resolved","v","promesa.impl/resolved","promesa.core/rejected","promesa.impl/rejected","promesa.core/deferred","promesa.impl/deferred","var_args","G__32996","promesa.core/promise","js/Error","promesa.protocols/-promise","executor","promesa.protocols/-map","cljs.core/identity","promesa.core/wrap","G__33002","promesa.core/create","f","d","e33003","G__33004","p1__32997#","G__33005","p1__32998#","promesa.protocols/-resolve!","promesa.protocols/-reject!","e","promesa.exec.run_BANG_","e33006","G__33007","p1__32999#","G__33008","p1__33000#","promesa.core/promise?","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","promesa.protocols/IPromise","promesa.core/deferred?","promesa.impl/*default-promise*","promesa.core/thenable?","cljs.core/object?","cljs.core/fn?","promesa.core/resolved?","p","promesa.protocols/-resolved?","promesa.core/rejected?","promesa.protocols/-rejected?","promesa.core/pending?","promesa.protocols/-pending?","promesa.core/extract","promesa.protocols/-extract","promesa.core/done?","cljs.core/complement","G__33011","promesa.core/then","promesa.protocols/-then","G__33013","promesa.core/bind","promesa.protocols/-bind","G__33015","promesa.core/then'","G__33017","promesa.core/map","G__33019","promesa.core/mapcat","G__33026","promesa.core/chain","args-arr__5794__auto__","len__5769__auto__","i__5770__auto__","argseq__5795__auto__","cljs.core/IndexedSeq","seq33023","G__33024","cljs.core/first","cljs.core/next","G__33025","self__5754__auto__","promesa.core.then","fs","p1__33020#","p2__33021#","cljs.core.reduce","cljs.core/cons","G__33031","promesa.core/chain'","seq33028","G__33029","G__33030","promesa.core.then_SINGLEQUOTE_","G__33033","promesa.core/handle","promesa.protocols/-handle","G__33035","promesa.core/finally","promesa.protocols/-finally","G__33038","promesa.core/catch","promesa.protocols/-thenErr","pred-or-type","accept?","p1__33036#","cljs.core/ifn?","G__33041","promesa.core/catch'","promesa.protocols/-mapErr","p1__33039#","G__33043","promesa.core/error","promesa.core.catch$","type","promesa.core/err","promesa.core/all","promises","cljs.core.into_array","cljs.core/vec","promesa.core/race","cljs.core.map","G__33045","promesa.core/any","promesa.core.any","default","state","cljs.core.atom","cljs.core/count","promesa.core.create","resolve","reject","seq__33046","cljs.core/seq","chunk__33047","count__33048","i__33049","temp__5720__auto__","cljs.core/chunked-seq?","c__5568__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/deref","cljs.core.swap_BANG_","cljs.core.assoc","cljs.core.update","cljs.core/dec","cljs.core/conj","map__33054","cljs.core/--destructure-map","cljs.core.get","map__33056","resolved","counter","rejections","cljs.core/not","cljs.core._EQ_","G__33055","G__33057","cljs.core.ex_info","G__33061","promesa.core/run!","coll","promesa.core.run_BANG_","promesa.exec/current-thread-executor","p1__33058#","p2__33059#","_","promesa.core.promise","promesa.core/cancel!","promesa.protocols/-cancel!","promesa.core/cancelled?","promesa.protocols/-cancelled?","G__33063","promesa.core/resolve!","o","promesa.core/reject!","promesa.core/promisify","callable","args","cljs.core.conj","e33064","cljs.core.apply","promesa.core/TimeoutException","message","it","goog/inherits","G__33066","promesa.core/timeout","t","promesa.core.timeout","promesa.exec/default-scheduler","scheduler","timeout","tid","promesa.exec.schedule_BANG_","promesa.core.resolve_BANG_","promesa.core.finally$","G__33068","promesa.core/delay","promesa.core.delay","promesa.core/*loop-run-fn*","promesa.exec/run!"],"sourcesContent":[";; Copyright (c) 2015-2019 Andrey Antukh <niwi@niwi.nz>\n;; All rights reserved.\n;;\n;; Redistribution and use in source and binary forms, with or without\n;; modification, are permitted provided that the following conditions\n;; are met:\n;;\n;; 1. Redistributions of source code must retain the above copyright\n;;    notice, this list of conditions and the following disclaimer.\n;; 2. Redistributions in binary form must reproduce the above copyright\n;;    notice, this list of conditions and the following disclaimer in the\n;;    documentation and/or other materials provided with the distribution.\n;;\n;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n;; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n;; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n;; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n;; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n(ns promesa.core\n  (:refer-clojure :exclude [delay spread promise\n                            await map mapcat run!\n                            future let loop recur\n                            -> ->> as-> with-redefs do])\n  (:require\n   [promesa.protocols :as pt]\n   [clojure.core :as c]\n   [promesa.exec :as exec]\n   [promesa.impl :as impl])\n  #?(:cljs (:require-macros [promesa.core]))\n  #?(:clj\n     (:import\n      java.util.concurrent.CompletableFuture\n      java.util.concurrent.CompletionStage\n      java.util.concurrent.TimeoutException)))\n\n;; --- Promise\n\n(defn resolved\n  \"Return a resolved promise with provided value.\"\n  [v]\n  (impl/resolved v))\n\n(defn rejected\n  \"Return a rejected promise with provided reason.\"\n  [v]\n  (impl/rejected v))\n\n(defn deferred\n  \"Creates an empty promise instance.\"\n  []\n  (impl/deferred))\n\n(defn promise\n  \"The coerce based promise constructor. Creates a appropriate promise\n  instance depending on the provided value.\n\n  If an executor is provided, it will be used to resolve this\n  promise.\"\n  ([v]\n   (pt/-promise v))\n  ([v executor]\n   (pt/-map (pt/-promise v) identity executor)))\n\n(defn wrap\n  \"A convenience alias for `promise` coercion function that only accepts\n  a single argument.\"\n  [v]\n  (pt/-promise v))\n\n(defn create\n  \"Create a promise instance from a factory function. If an executor is\n  provided, the factory will be executed in the provided executor.\n\n  A factory function looks like `(fn [resolve reject] (resolve 1))`.\"\n  ([f]\n   (c/let [d (impl/deferred)]\n     (try\n       (f #(pt/-resolve! d %)\n          #(pt/-reject! d %))\n       (catch #?(:clj Exception :cljs :default) e\n         (pt/-reject! d e)))\n     d))\n  ([f executor]\n   (c/let [d (impl/deferred)]\n     (exec/run! executor (fn []\n                           (try\n                             (f #(pt/-resolve! d %)\n                                #(pt/-reject! d %))\n                             (catch #?(:clj Exception :cljs :default) e\n                               (pt/-reject! d e)))))\n     d)))\n\n(defn promise?\n  \"Return true if `v` is a promise instance.\"\n  [v]\n  (satisfies? pt/IPromise v))\n\n  ;; #?(:clj (instance? CompletionStage v)\n  ;;    :cljs (instance? impl/*default-promise* v)))\n\n(defn deferred?\n  \"Return true if `v` is a promise instance (alias to `promise?`).\"\n  [v]\n  #?(:clj (instance? CompletionStage v)\n     :cljs (instance? impl/*default-promise* v)))\n\n#?(:cljs\n   (defn thenable?\n     \"Returns true if `v` is a promise like object.\"\n     [v]\n     (and (object? v) (fn? (unchecked-get v \"then\")))))\n\n;; Predicates\n\n(defn resolved?\n  \"Returns true if promise `p` is already fulfilled.\"\n  [p]\n  (pt/-resolved? p))\n\n(defn rejected?\n  \"Returns true if promise `p` is already rejected.\"\n  [p]\n  (pt/-rejected? p))\n\n(defn pending?\n  \"Returns true if promise `p` is stil pending.\"\n  [p]\n  (pt/-pending? p))\n\n(defn extract\n  \"Returns the current promise value.\"\n  [p]\n  (pt/-extract p))\n\n(def done?\n  \"Returns true if promise `p` is already done.\"\n  (complement pending?))\n\n;; Chaining\n\n(defn then\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  If the function `f` returns a promise instance, it will be\n  automatically unwrapped.\"\n  ([p f]\n   (pt/-then (pt/-promise p) f))\n  ([p f executor]\n   (pt/-then (pt/-promise p) f executor)))\n\n(defn bind\n  ([p f]\n   (pt/-bind (pt/-promise p) f))\n  ([p f executor]\n   (pt/-bind (pt/-promise p) f executor)))\n\n(defn then'\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  The computation will be executed in the calling thread by default;\n  you also can provide a custom executor.\n\n  Don't perform flatten on the result.\"\n  ([p f]\n   (pt/-map (pt/-promise p) f))\n  ([p f executor]\n   (pt/-map (pt/-promise p) f executor)))\n\n(defn map\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved.\n\n  Unlike `then` this does not performs automatic promise flattening.\n  This is designed to be used with `->>`.\"\n  ([f p]\n   (pt/-map (pt/-promise p) f))\n  ([executor f p]\n   (pt/-map (pt/-promise p) f executor)))\n\n(defn mapcat\n  \"Chains a computation `f` (function) to be executed when the promise\n  `p` is successfully resolved. always expecting that `f` returns a\n  promise that will be automatically unwrapped.\n\n  This is just a stricter version of `then` with reversed arguments in\n  the same way as `map`.\n\n  This is designed to be used with `->>`.\"\n  ([f p]\n   (pt/-bind (pt/-promise p) f))\n  ([executor f p]\n   (pt/-bind (pt/-promise p) f executor)))\n\n(defn chain\n  \"Chain variable number of computations to be executed\n  serially. Analogous to `then` that accepts variable number of\n  functions.\"\n  ([p f] (then p f))\n  ([p f & fs] (reduce #(then %1 %2) p (cons f fs))))\n\n(defn chain'\n  \"Chain variable number of computations to be executed serially. Unlike\n  `chain` does not flattens the return value of each step (probably\n  this is more performant than `chain`).\"\n  ([p f] (then' p f))\n  ([p f & fs] (reduce pt/-map (pt/-promise p) (cons f fs))))\n\n(defn handle\n  \"Executes `f` when the promise `p` is resolved or is rejected. Returns\n  a promise resolved with the return value of `f` function.\"\n  ([p f]\n   (pt/-handle (pt/-promise p) f))\n  ([p f executor]\n   (pt/-handle (pt/-promise p) f executor)))\n\n(defn finally\n  \"Attach a potentially side-effectful handler to promise that will be\n  executed independently if promise is resolved or rejected.\n\n  Returns the original promise and the return value of `f` function is\n  ignored.\"\n  ([p f]\n   (pt/-finally (pt/-promise p) f))\n  ([p f executor]\n   (pt/-finally (pt/-promise p) f executor)))\n\n(defn catch\n  \"Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.\"\n  ([p f]\n   (pt/-thenErr (pt/-promise p) f))\n  ([p pred-or-type f]\n   (c/let [accept? (if (ifn? pred-or-type)\n                     pred-or-type\n                     #(instance? pred-or-type %))]\n     (pt/-thenErr\n      (pt/-promise p)\n      (fn [e]\n        (if (accept? e)\n          (f e)\n          (impl/rejected e)))))))\n\n(defn catch'\n  \"Executes `f` when the promise `p` is rejected. Returns a promise\n  resolved with the return value of `f` function handler.\"\n  ([p f]\n   (pt/-mapErr (pt/-promise p) f))\n  ([p pred-or-type f]\n   (c/let [accept? (if (ifn? pred-or-type)\n                     pred-or-type\n                     #(instance? pred-or-type %))]\n     (pt/-mapErr\n      (pt/-promise p)\n      (fn [e]\n        (if (accept? e)\n          (f e)\n          (impl/rejected e)))))))\n\n(defn error\n  \"Same as `catch` but with parameters inverted.\"\n  ([f p] (catch p f))\n  ([f type p] (catch p type f)))\n\n(def err\n  \"A short alias for `error` function.\"\n  error)\n\n(defn all\n  \"Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \\\", \\\" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected.\"\n  [promises]\n  #?(:cljs (c/-> (.all impl/*default-promise* (into-array promises))\n                 (then' vec))\n     :clj (c/let [promises (clojure.core/map pt/-promise promises)]\n            (then' (c/->> (into-array CompletableFuture promises)\n                          (CompletableFuture/allOf))\n                   (fn [_]\n                     (mapv pt/-extract promises))))))\n\n(defn race\n  [promises]\n  #?(:cljs (.race impl/*default-promise* (into-array (cljs.core/map pt/-promise promises)))\n     :clj (CompletableFuture/anyOf (c/->> (clojure.core/map pt/-promise promises)\n                                          (into-array CompletableFuture)))))\n\n(defn any\n  \"Given an array of promises, return a promise that is fulfilled when\n  first one item in the array is fulfilled.\"\n  ([promises]\n   (any promises ::default))\n  ([promises default]\n   (c/let [state (atom {:resolved false\n                        :counter (count promises)\n                        :rejections []})]\n     (create\n      (fn [resolve reject]\n        (doseq [p promises]\n          (c/-> (pt/-promise p)\n                (then (fn [v]\n                        (when-not (:resolved @state)\n                          (swap! state (fn [state]\n                                         (c/-> state\n                                               (assoc :resolved true)\n                                               (update :counter dec))))\n                          (resolve v))))\n                (catch (fn [e]\n                         (swap! state (fn [state]\n                                        (c/-> state\n                                              (update  :counter dec)\n                                              (update :rejections conj e))))\n                         (c/let [{:keys [resolved counter rejections]} @state]\n                           (when (and (not resolved) (= counter 0))\n                             (if (= default ::default)\n                               (reject (ex-info \"No promises resolved\"\n                                                {:rejections rejections}))\n                               (resolve default)))))))))))))\n\n(defn run!\n  \"A promise aware run! function.\"\n  ([f coll] (run! f coll exec/current-thread-executor))\n  ([f coll executor] (reduce #(then %1 (fn [_] (f %2))) (promise nil executor) coll)))\n\n;; Cancellation\n\n(defn cancel!\n  \"Cancel the promise.\"\n  [p]\n  (pt/-cancel! p)\n  p)\n\n(defn cancelled?\n  \"Return true if `v` is a cancelled promise.\"\n  [v]\n  (pt/-cancelled? v))\n\n;; Completable\n\n(defn resolve!\n  \"Resolve a completable promise with a value.\"\n  ([o] (pt/-resolve! o nil))\n  ([o v] (pt/-resolve! o v)))\n\n(defn reject!\n  \"Reject a completable promise with an error.\"\n  [p e]\n  (pt/-reject! p e))\n\n;; --- Utils\n\n(defn promisify\n  \"Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation).\"\n  [callable]\n  (fn [& args]\n    (create (fn [resolve reject]\n               (c/let [args (c/-> (vec args) (conj resolve))]\n                 (try\n                   (apply callable args)\n                   (catch #?(:clj Throwable :cljs js/Error) e\n                     (reject e))))))))\n\n#?(:cljs\n   (defn ^{:jsdoc [\"@constructor\"]}\n     TimeoutException [message]\n     (this-as it\n       (.call js/Error it message {} nil)\n       it)))\n\n#?(:cljs (goog/inherits TimeoutException js/Error))\n\n(defn timeout\n  \"Returns a cancellable promise that will be fulfilled with this\n  promise's fulfillment value or rejection reason.  However, if this\n  promise is not fulfilled or rejected within `ms` milliseconds, the\n  returned promise is cancelled with a TimeoutError\"\n  ([p t] (timeout p t ::default exec/default-scheduler))\n  ([p t v] (timeout p t v exec/default-scheduler))\n  ([p t v scheduler]\n   (c/let [timeout (deferred)\n           tid     (exec/schedule! scheduler t #(if (= v ::default)\n                                                  (reject! timeout (TimeoutException. \"Operation timed out.\"))\n                                                  (resolve! timeout v)))]\n     (race [(finally p (fn [_ _] (pt/-cancel! tid))) timeout]))))\n\n(defn delay\n  \"Given a timeout in miliseconds and optional value, returns a promise\n  that will fulfilled with provided value (or nil) after the time is\n  reached.\"\n  ([t] (delay t nil exec/default-scheduler))\n  ([t v] (delay t v exec/default-scheduler))\n  ([t v scheduler]\n   (c/let [d (deferred)]\n     (exec/schedule! scheduler t #(resolve! d v))\n     d)))\n\n(defmacro do!\n  \"Execute potentially side effectful code and return a promise resolved\n  to the last expression. Always awaiting the result of each\n  expression.\"\n  [& exprs]\n  `(pt/-bind\n    (pt/-promise nil)\n    (fn [_#]\n      ~(condp = (count exprs)\n         0 `(pt/-promise nil)\n         1 `(pt/-promise ~(first exprs))\n         (reduce (fn [acc e]\n                   `(pt/-bind (pt/-promise ~e) (fn [_#] ~acc)))\n                 `(pt/-promise ~(last exprs))\n                 (reverse (butlast exprs)))))))\n\n\n(defmacro do\n  \"An alias for do!\"\n  [& exprs]\n  `(do! ~@exprs))\n\n(defmacro let\n  \"A `let` alternative that always returns promise and waits for all the\n  promises on the bindings.\"\n  [bindings & body]\n  `(pt/-bind\n    (pt/-promise nil)\n    (fn [_#]\n      ~(c/->> (reverse (partition 2 bindings))\n              (reduce (fn [acc [l r]]\n                        `(pt/-bind (pt/-promise ~r) (fn [~l] ~acc)))\n                      `(do! ~@body))))))\n\n(defmacro plet\n  \"A parallel let; executes all the bindings in parallel and when all\n  bindings are resolved, executes the body.\"\n  [bindings & body]\n  `(pt/-bind\n    (pt/-promise nil)\n    (fn [_#]\n      ~(c/let [bindings (partition 2 bindings)]\n         `(c/-> (all ~(mapv second bindings))\n                (then (fn [[~@(mapv first bindings)]]\n                        (do! ~@body))))))))\n\n(defmacro future\n  \"Analogous to `clojure.core/future` that returns a promise instance\n  instead of the `Future`. Usefull for execute synchronous code in a\n  separate thread (also works in cljs).\"\n  [& body]\n  `(c/-> (exec/submit! (fn []\n                         (c/let [f# (fn [] ~@body)]\n                           (pt/-promise (f#)))))\n         (pt/-bind identity)))\n\n(def ^:dynamic *loop-run-fn* exec/run!)\n\n(defmacro loop\n  [bindings & body]\n  (c/let [bindings (partition 2 2 bindings)\n          names (mapv first bindings)\n          fvals (mapv second bindings)\n          tsym (gensym \"loop\")\n          dsym (gensym \"deferred\")\n          rsym (gensym \"run\")]\n    `(c/let [~rsym *loop-run-fn*\n             ~dsym (promesa.core/deferred)\n             ~tsym (fn ~tsym [params#]\n                     (c/-> (promesa.core/all params#)\n                           (promesa.core/then (fn [[~@names]]\n                                                ;; (prn \"exec\" ~@names)\n                                                (do! ~@body)))\n                           (promesa.core/handle\n                            (fn [res# err#]\n                              ;; (prn \"result\" res# err#)\n                              (cond\n                                (not (nil? err#))\n                                (promesa.core/reject! ~dsym err#)\n\n                                (and (map? res#) (= (:type res#) :promesa.core/recur))\n                                (do (~rsym (fn [] (~tsym (:args res#))))\n                                    nil)\n\n                                :else\n                                (promesa.core/resolve! ~dsym res#))))))]\n       (~rsym (fn [] (~tsym ~fvals)))\n       ~dsym)))\n\n(defmacro recur\n  [& args]\n  `(array-map :type :promesa.core/recur :args [~@args]))\n\n(defmacro ->\n  \"Like the clojure.core/->, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise. Example using to fetch data in the browser with CLJS:\n\n  Example:\n\n  (p/-> (js/fetch #js {...}) ; returns a promise\n        .-body)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.\"\n  [x & forms]\n  (c/let [fns (mapv (fn [arg]\n                      (c/let [[f & args] (if (sequential? arg)\n                                           arg\n                                           (list arg))]\n                        `(fn [p#] (~f p# ~@args)))) forms)]\n    `(chain (promise ~x) ~@fns)))\n\n(defmacro ->>\n  \"Like the clojure.core/->>, but it will handle promises in values\n  and make sure the next form gets the value realized instead of\n  the promise. Example using to fetch data in the browser with CLJS:\n\n  Example:\n\n  (p/->> (js/fetch #js {...}) ; returns a promise\n         .-body\n         read-string\n         (mapv inc)\n\n  The result of a thread is a promise that will resolve to the\n  end of the thread chain.\"\n  [x & forms]\n  (c/let [fns (mapv (fn [arg]\n                      (c/let [[f & args] (if (sequential? arg)\n                                           arg\n                                           (list arg))]\n                        `(fn [p#] (~f ~@args p#)))) forms)]\n    `(chain (promise ~x) ~@fns)))\n\n(defmacro as->\n  \"Like clojure.core/as->, but it will handle promises in values\n   and make sure the next form gets the value realized instead of\n   the promise.\"\n  [expr name & forms]\n  `(let [~name ~expr\n         ~@(interleave (repeat name) (butlast forms))]\n     ~(if (empty? forms)\n        name\n        (last forms))))\n\n(defmacro with-redefs\n  \"Like clojure.core/with-redefs, but it will handle promises in\n   body and wait until they resolve or reject before restoring the\n   bindings. Useful for mocking async APIs.\"\n  [bindings & body]\n  (c/let [names         (take-nth 2 bindings)\n          vals          (take-nth 2 (drop 1 bindings))\n          orig-val-syms (c/map (comp gensym #(str % \"-orig-val__\") name) names)\n          temp-val-syms (c/map (comp gensym #(str % \"-temp-val__\") name) names)\n          binds         (c/map vector names temp-val-syms)\n          resets        (reverse (c/map vector names orig-val-syms))\n          bind-value    (if (:ns &env)\n                          (fn [[k v]] (list 'set! k v))\n                          (fn [[k v]] (list 'alter-var-root (list 'var k) (list 'constantly v))))]\n    `(c/let [~@(interleave orig-val-syms names)\n             ~@(interleave temp-val-syms vals)]\n       ~@(c/map bind-value binds)\n       (c/-> (promesa.core/do! ~@body)\n             (promesa.core/finally\n               (fn [_# _#]\n                 ~@(c/map bind-value resets)))))))\n"]}